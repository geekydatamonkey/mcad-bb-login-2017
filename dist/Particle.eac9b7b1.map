{"version":3,"sources":["proto/js/Particle.js"],"names":["Particle","sketch","position","createVector","radius","velocity","acceleration","maxVelocity","color","previousPosition","x","y","anotherParticle","copy","sub","dx","dy","Error","dist","width","height","set","limit","add","correctForEdgeWrap","s","push","noStroke","fill","ellipse","pop"],"mappings":"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","file":"Particle.eac9b7b1.map","sourceRoot":"..","sourcesContent":["class Particle {\n  constructor({ sketch, position }) {\n    const { createVector } = sketch;\n    this.sketch = sketch || null;\n    this.radius = 10;\n    this.position = position || createVector(0, 0);\n    this.velocity = createVector(0, 0);\n    this.acceleration = createVector(0, 0);\n    this.maxVelocity = 100;\n    this.color = \"white\";\n\n    // for verlet integration we need to keep track of the old position\n    // We calculate where the particle would have been in the past\n    this.previousPosition = createVector(\n      this.position.x - this.velocity.x,\n      this.position.y - this.velocity.y\n    );\n  }\n\n  /*\n  * returns a vector from this particle's position\n  * to another particle's position\n  */\n  getVectorTo(anotherParticle) {\n    return anotherParticle.position.copy().sub(this.position);\n  }\n\n  /**\n   * returns the distance^2 (magnitude) between\n   * this particle and another particle\n   *\n   * this function may be more useful in particle systems\n   * since we avoid finding the distance (which involves\n   * a sqrt) and then squaring it again.\n   */\n  getDistSqTo(anotherParticle) {\n    let dx = this.position.x - anotherParticle.position.x;\n    let dy = this.position.y - anotherParticle.position.y;\n    return dx * dx + dy * dy;\n  }\n\n  getDistTo(anotherParticle) {\n    if (!(anotherParticle instanceof Particle)) {\n      throw Error(\n        `getDistanceTo(): cannot get distance between ${this} and other particle '${anotherParticle}'`\n      );\n    }\n\n    return this.position.dist(anotherParticle.position);\n  }\n\n  correctForEdgeWrap() {\n    // off right edge, wrap around to left\n    if (this.position.x > this.sketch.width) {\n      this.position.x = 0;\n      this.previousPosition.x = this.position.x - this.velocity.x;\n    }\n\n    // off left edge\n    if (this.position.x < 0) {\n      this.position.x = this.sketch.width;\n      this.previousPosition.x = this.position.x - this.velocity.x;\n    }\n\n    // off top edge\n    if (this.position.y < 0) {\n      this.position.y = this.sketch.height;\n      this.previousPosition.y = this.position.y - this.velocity.y;\n    }\n\n    // off bottom edge\n    if (this.position.y > this.sketch.height) {\n      this.position.y = 0;\n      this.previousPosition.y = this.position.y - this.velocity.y;\n    }\n  }\n\n  /**\n   * update position using Verlet Integration\n   */\n  update() {\n    // calulate new velocity\n    // note we use previousPosition and position to calc current velocity\n    this.velocity.set(\n      this.position.x - this.previousPosition.x + this.acceleration.x,\n      this.position.y - this.previousPosition.y + this.acceleration.y\n    );\n\n    // keep the velocity within the bounds of maxVelocity\n    this.velocity.limit(this.maxVelocity);\n\n    // update previousPosition\n    this.previousPosition.set(this.position.copy());\n\n    // update current position, taking the above calculated velocity into account\n    this.position.add(this.velocity);\n\n    // handle edge cases\n    this.correctForEdgeWrap();\n\n    return this;\n  }\n  render() {\n    const s = this.sketch;\n    if (!s) throw Error(\"Cannot render. No sketch is set for this particle.\");\n\n    s.push();\n    s.push();\n    s.noStroke();\n    s.fill(this.color);\n    s.ellipse(this.position.x, this.position.y, this.radius, this.radius);\n    s.pop();\n\n    return this;\n  }\n}\n"]}